<!DOCTYPE html>
<html>
<head>
    <title>NETIT - GENERETED HTML</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="style.css" />
</head>
<body class="body-std">
<canvas id="particles-canvas"></canvas>
<article class="article">
    <h1 class="h1">Historia Linuxa</h1>
    <h2 class="h2">Czat grupowy</h2>
    <p>Naszą opowieść rozpoczniemy od roku 1991 kiedy Linus Torvalds był studentem Informatyki (eng. Computer Science) na Uniwersytecie Helsinki. Dziewiętnastego Sierpień postanowił on napisać wiadomość do grupy Usenet comp.os.minix na swoim uniwersytecie. Brzmiała ona następująco:</p>
    <pre>„ I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu)
        for 386(486) AT clones. This has been brewing since April and is starting to get ready.
        I'd like any feedback on things people like/dislike in minix, as my OS resembles it somewhat
        (same physical layout of the file-system due to practical reasons among other things). ”</pre>
    <p>Lub po przetłumaczeniu: "Tworzę (darmowy) system operacyjny (tylko jako hobby – nie będzie duży ani profesjonalny jak GNU) dla klonów 386(486) AT. Pracuję nad nim od kwietnia i zaczyna być gotowy. Chciałbym poznać opinie na temat tego, co ludziom się podoba lub nie podoba w Miniksie, ponieważ mój system operacyjny w pewnym stopniu go przypomina (między innymi ten sam fizyczny układ systemu plików, z powodów praktycznych)."</p>
    <h2 class="h2">17 września 1991 -wersja 0.01</h2>
    <p>Wersja 0.01 była pierwszym pełnoprawnym wydaniem Linuxa (w wersji pre-alfa). Posiadała ona około 10 000 linii kodu w 88 plikach. To wydanie oprócz samego jądra posiadało skompresowany plik binarny bash.z oraz skompresowany plik binarny aktualizacji update.z . Z informacji o tym wydaniu dowiadujemy się że jest to wolne jądro podobne do minix dla maszyn AT opartych na i386(+) oraz że nie ma dostępnej publicznie już skompilowanej wersji systemu z czego wynika że każdy musi sam skompilować jądro na potrzeby swojej maszyny. Zaleca się je kompilować za pocą gcc oraz jesteśmy informowani o wersji kompilatora autora 1.40 razem z dygresją o potencjalny braku wsparcia dla wstawek napisanych w assembly przez wersje 1.37.1. Co istotne i warte zaznaczenia ta wersja była „pokazówką” kodu a nie pełnoprawnym system „Ta wersja jest przeznaczona głównie do przeglądania – jeśli chcesz zobaczyć, jak system wygląda obecnie. Skompiluje się i wygeneruje działające jądro, i choć pomogę, jak tylko będę mógł, żeby uruchomić je na Twojej maszynie (napisz do mnie), to nie jest ono jednak oficjalnie wspierane.„ czyli niestety jeśli miałeś okazję żyć w tamtym okresie i posiadać swój komputer prawdopodobnie bez zaawansowanej wiedzy informatyczno-programistycznej  nie byłbyś w stanie ani uruchomić ani skompilować tego jądra. Dla ciekawski udało mi się znaleźć artykuł jak w dzisiejszych czasach uruchomić tą wersje Linuxa za pomocą QEMU - https://computernewb.com/wiki/Linux_0.01 . </p>
    <p>W trakcie zapoznawania się z tym wydaniem dowiadujemy się o licencji projektu:</p>
    <p>Eng (oryginał) :</p>
    <pre>2. Copyrights etc
    This kernel is (C) 1991 Linus Torvalds, but all or part of it may be
    redistributed provided you do the following:
            - Full source must be available (and free), if not with the
              distribution then at least on asking for it.
            - Copyright notices must be intact. (In fact, if you distribute
              only parts of it you may have to add copyrights, as there aren't
             (C)'s in all files.) Small partial excerpts may be copied
              without bothering with copyrights.
            - You may not distibute this for a fee, not even "handling"
              costs.
    Mail me at "torvalds@kruuna.helsinki.fi" if you have any questions.
    Sadly, a kernel by itself gets you nowhere. To get a working system you
    need a shell, compilers, a library etc. These are separate parts and may
    be under a stricter (or even looser) copyright. Most of the tools used
    with linux are GNU software and are under the GNU copyleft. These tools
    aren't in the distribution - ask me (or GNU) for more info.</pre>
    <p>Schodząc do przeglądu technicznego jądra jesteśmy informowani o kilku interesujących zależnościach. Linus pierwotnie planował wsparcie dla kompatybilności binarnej z minixem, jednakże zrezygnował z tego ponieważ w trakcji pisania kodu różnice między systemami coraz bardziej się powiększały. Jednak systemy nadal były względem siebie nawzajem bardzo podobne. Linux zawsze celował w wydajność, już w tym wydaniu widzimy lepsze wykorzystanie zasobów układu 386 względem minixa, ponieważ minix został napisany na układzie  8088, a dopiero później przeniesiony na inne maszyny. Dla przypomnienia mamy rok 1991 a układ 386 znany również jako Intel 80386 był 32-bitowym mikroprocesor wprowadzony na rynek w 1985 roku. Był to pierwszy 32-bitowy procesor Intela, który komunikował się za pomocą 32-bitowej magistrali danych i 32-bitowej magistrali adresowej. Układ ten oferował trzy tryby pracy: rzeczywisty, chroniony i wirtualny. W trybie chronionym 386 mógł adresować do 4 GB pamięci fizyczne. Do porównania z jednym z tańszych aktualnych procesorów Intel® Core™ i5 processor 14400F do nabycia za około 600 zł. Posiada on częstotliwość 4.7 GHZ do porównania z 12 MHz, czyli jedynie 4 700 000 000 Hz /  12 000 000 Hz =  391,666666667 razy szybszy procesor na jeden rdzeń na korzyść i5 oraz z maksymalną obsługiwaną ilością RAMu 192 GB. Co raczej wystarczająco zaznacza jak ważne wtedy były zasoby z uwagi, że teraz z kilkaset raz szybszymi procesorami czekamy długo na załadowanie systemu. Kolejnym podpunktem jest brak mechanizmu przekazywania komunikatów. To bardziej tradycyjne podejście w stylu Uniksa. Wywołania systemowe są po prostu wywołaniami – bez dodatkowej warstwy komunikacji. Może to (choć nie musi) skutkować lepszą wydajnością, a przede wszystkim pozwala uniknąć pewnych problemów związanych z obsługą komunikatów, takich jak kolejki czy blokady. Oczywiście… trochę tęsknimy za tymi „wypasionymi” funkcjami. Już w tym wydaniu spotykamy wielowątkowość która spowodowała skomplikowanie systemu plików  ale poprawiła samą interakcje z nim. Łącząc to z harmonogramem oznacza to możliwość uruchomienia  kilku procesów jednocześnie bez spadku wydajności. Minimalne przełączanie zadań to również konsekwencja braku mechanizmu komunikatów. Przełączamy procesy tylko wtedy, gdy naprawdę zachodzi taka potrzeba - w przeciwieństwie do Miniksa, który robi to niezależnie od aktualnie wykonywanych operacji. Dzięki temu znacznie łatwiej jest zaimplementować obsługę koprocesora 387 (co w rzeczywistości jest już w dużej mierze zrealizowane). </p>
    <p>Przerwanie (ang. interrupt) w Linuksie nigdy nie było traktowane jak jakieś podstępne, ukryte zjawisko – wręcz przeciwnie, autor jądra uznał, że nie ma powodu, by je zacierać. W praktyce obsługa przerwań odbywa się prawie wyłącznie w kodzie maszynowym, co z jednej strony jest koniecznością, z drugiej - pewnym kompromisem między szybkością reakcji a czytelnością kodu. Przerwania traktuje się tutaj jak każdą inną część systemu: są fragmentem kodu tak samo ważnym jak pozostałe, a zwłaszcza kluczowym elementem sterowników urządzeń. To właśnie w podkatalogu kernel znajdziemy procedury obsługi przerwań dysku twardego czy terminala, np. w pliku hd.c, gdzie każde wywołanie przerwania zmusza jądro do natychmiastowego wykonania odpowiedniej sekwencji instrukcji. Podejście to pozwala zachować pełną kontrolę nad sprzętem i uniknąć subtelnych błędów, jakie mogą pojawić się przy bardziej „wysublimowanych” metodach maskowania czy kolejkowania przerwań.</p>
    <p>W Linuksie nie ma sztucznego podziału na poszczególne podsystemy jądra, takie jak kernel, fs czy mm - wszystkie te obszary łączy wspólna, jednolita przestrzeń kodu oraz danych. Choć na pierwszy rzut oka może się to wydawać mniej uporządkowane niż modularna struktura Miniksa, umożliwia to prostsze wywołania funkcji z dowolnego miejsca w kodzie i eliminuje narzut związany z komunikacją międzyprocesową czy mechanizmami RPC (remote procedure call). W strukturalnym drzewie źródeł poszczególne komponenty znajdują się co prawda w osobnych katalogach, jednak po skompilowaniu wszystko ląduje w jednym wspólnym „kupie” kodu wykonywalnego. To z kolei wpływa na szybkość działania i pozwala uniknąć niepotrzebnych przełączeń kontekstu, choć jednocześnie wprowadza większe ryzyko awarii - pojedynczy błąd w sterowniku może zresetować cały system.</p>
    <p>Główną zasadą przyświecającą Linusowi Torvaldsowi podczas pisania pierwszych wersji jądra było uzyskanie w miarę sprawnego, ale przede wszystkim szybkiego prototypu. Nie dążył do stworzenia arcyprecyzyjnego, dogłębnie przemyślanego produktu od razu - chciał uzyskać jądro proste, lecz wystarczająco wydajne, by uruchomić większość programów napisanych dla tradycyjnych systemów Unix. Ze względu na praktyczne względy jądro musiało być kompatybilne z systemem plików Miniksa. Był on bowiem prosty, dobrze znany i umożliwiał łatwe przenoszenie danych między systemami; w zamierzeniu miał się sprawdzić jako tymczasowe rozwiązanie, dopóki nie powstanie autorski FS Linuksa, co nigdy w zasadzie nie nastąpiło.</p>
    <p>Redukcja złożoności dotknęła także strukturę przechowywania informacji o procesach - zamiast rozproszenia po wielu, odległych od siebie fragmentach kodu, cała definicja procesu umieszczona została w jednej, wspólnej strukturze danych. W tradycyjnych systemach Unix informacje o zadaniach często rozdzielano na różne tabele czy listy; w Linuksie zadbano o to, aby wszystkie istotne atrybuty procesu - stan, licznik programu, wskaźniki na stosy, mapy pamięci - znalazły się w jednym miejscu. Dzięki temu implementacja mechanizmu tworzenia nowych procesów metodą fork() oraz ich zakończenia exit() stała się prostsza, a kod czytelniejszy i łatwiejszy do debugowania.</p>
    <p>Podobnie oszczędne podejście zastosowano w module zarządzania pamięcią. Zamiast rozbudowanych, wieloetapowych algorytmów, zredukowano ją do zaledwie dwóch plików – memory.c i page.s - o łącznej objętości kilkuset linii. Wykorzystano przy tym pełne możliwości i386: zarówno segmentację, jak i stronicowanie. Cała przestrzeń wirtualna (4 GB) dzielona jest na 64 segmenty o rozmiarze 64 MB każdy. Pierwszy segment jest zarezerwowany dla jądra i zawiera fizyczną pamięć odwzorowaną „jeden do jednego”. Pozostałe segmenty przydzielane są zadaniom użytkownika. Mechanizm stronicowania odpowiada za kopiowanie stron przy zapisie (copy-on-write) oraz zarządzanie tabelami stron, ale reszta jądra nie musi wiedzieć o szczegółach - wystarczy, że zapis do nieistniejącej strony wygeneruje wyjątek, który moduł mm obsłuży, dopisując dane i aktualizując struktury.</p>
    <p>System plików w Linuksie od początku był identyczny z tym z Miniksa. Dzięki temu można montować partycję Linuksa w systemie Minix i odwrotnie – przynajmniej na poziomie logicznym. Wewnętrzne implementacje funkcji czy buforowania różnią się jednak znacząco. W Miniksie system plików pracuje w pojedynczym wątku, co upraszcza zarządzanie buforami bloków i eliminuje ryzyko zakleszczeń czy współbieżnych modyfikacji. W Linuksie z kolei zrezygnowano z globalnych blokad – każda operacja na strukturach danych jest krótkotrwała i nie wymaga długich locków, co praktycznie wyklucza deadlocki, ale jednocześnie naraża na warunki wyścigowe. Te zaś rozwiązuje się drogą wielokrotnego sprawdzania stanu pamięci i współbieżnych przydziałów (zob. fs/buffer.c czy fs/inode.c). Ważnym zabezpieczeniem jest też zakaz wywoływania funkcji sleep() w kodzie jądra, co gwarantuje atomowość większości operacji – o ile nie pojawi się wyjątek przerwania.</p>
    <p>Autor jądra nie ukrywał, że to wczesna, źródłowa wersja, przeznaczona głównie do oglądania i eksperymentów, a nie do produkcji. W sekcji „przeprosiny” zaznaczał, że choć z czasem pojawi się stabilne wydanie 1.0, wiele osób i tak może woleć pozostać przy Miniksie. Jądro wymaga jeszcze powłoki, kompilatorów i bibliotek - narzędzi zwykle dostarczanych przez projekt GNU na licencji copyleft. W liście zachęcał również do zgłaszania uwag, błędów i sugestii drogą mailową, co zresztą stało się podstawą modelu otwartego rozwoju Linuksa.</p>
    <p>Ostatecznie opis „rozruchu” jądra był dość prymitywny: wystarczała zmiana niektórych definicji w include/linux/config.h, dopasowanie typu stacji A-floppy w boot/boot.s, a potem proste polecenie make, które generowało plik Image. Ten kopiowało się na dyskietkę (np. cp Image /dev/ps0) i po włożeniu do napędu i restarcie komputer startował z nowym jądrem. Aby system cokolwiek robił, należało jeszcze wgrać binaria /bin/sh (sym-link do bash) oraz program update - w ten sposób uzyskiwało się minimalne, działające środowisko do dalszych eksperymentów i developmentu.</p>
    <p>Ten minimalistyczny, ale przemyślany projekt - z ciągłym naciskiem na prostotę, czytelność kodu i szybkość działania - stał się fundamentem, na którym dziś opiera się ogromny, modularny i jednocześnie monolityczny kernel Linuksa, używany w miliardach urządzeń na całym świecie.</p>
    <p>Jeśli faktycznie doszedłeś do tego momentu to zadajesz sobie pytanie po co ci ta wiedza i co to ma wspulnego za aktualnym linuxem. Wbrew pozorom ten archaiczny kod działa podobnie do dzisiejszej architektury tylko teraz mamy więcej optymalizacji, bardziej rozbowane narzędzia oraz firmy tworzące oprogramowanie na Linux.</p>
</article>
</body>
</html>
